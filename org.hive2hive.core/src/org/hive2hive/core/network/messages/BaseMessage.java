package org.hive2hive.core.network.messages;

import java.io.Serializable;
import java.math.BigInteger;
import java.security.SecureRandom;

import net.tomp2p.futures.FutureDHT;

import org.hive2hive.core.H2HConstants;
import org.hive2hive.core.log.H2HLogger;
import org.hive2hive.core.log.H2HLoggerFactory;
import org.hive2hive.core.network.NetworkManager;

/**
 * This is the base class of all messages used by <code>Hive2Hive</code>.</br>
 * All messages are sent to their destination in an asynchronous manner.<br>
 * </br>
 * 
 * <b>Design decision:</b></br> All messages in <code>Hive2Hive</code> have to
 * be send asynchronously. The reason is simply to avoid timeouts caused by
 * blocking threads which wait for the messages return/completion. If we wait
 * for a message to return and block the current thread (the synchronous way of
 * doing it) the current node itself is not able to reply on incoming messages.
 * This leads to timeouts for requesters and as a consequence to messages routed
 * to the 'wrong' peer/node because <code>TomP2P</code> thinks the current node
 * has left the network...</br></br>
 * 
 * Messages are sent by the {@link MessageManager}. For more details please have
 * a look at {@link MessageManager#send(AsynchronousMessage)}.
 * 
 * @author Nendor
 * 
 */
public abstract class BaseMessage implements Runnable, Serializable {

	private static final H2HLogger logger = H2HLoggerFactory.getLogger(BaseMessage.class);

	private static final long serialVersionUID = 8896590561336373601L;

	/**
	 * Determines how a message should be handled if a failure in the sending to
	 * the target node occurs.
	 * 
	 * @author Nendor
	 */
	public enum SendingBehavior {
		/** This message should be sent only once */
		SEND_ONCE,
		/**
		 * In case of a sending failure this message should be resent up to
		 * {@link B2BConstants#MAX_SEND_MESSAGE_TRIES} times
		 */
		SEND_MAX_ALLOWED_TIMES
	};

	protected NetworkManager networkManager;

	private final String messageID;
	private final String targetKey;
	private final SendingBehavior sendingBehavior;
	private int sendingCounter = 0;

	/**
	 * Constructor for an asynchronous message.
	 * 
	 * @param messageID
	 *            the ID of this message - should be chosen uniquely if possible
	 * @param targetKey
	 *            the key identifying the target of this message
	 * @param sendingBehavior
	 *            the sending behavior used for this message
	 */
	public BaseMessage(String messageID, String targetKey, SendingBehavior sendingBehavior) {
		logger.debug(String.format("MessageID='%S'", messageID));
		this.messageID = messageID;
		this.targetKey = targetKey;
		this.sendingBehavior = sendingBehavior;
	}

	/**
	 * Constructor for an asynchronous message.</br> This constructor creates an
	 * asynchronous message with the default sending behavior {@link SendingBehavior#SEND_MAX_ALLOWED_TIMES}.
	 * 
	 * @param messageID
	 *            the ID of this message - should be chosen uniquely if possible
	 * @param targetKey
	 *            the key identifying the target of this message
	 */
	public BaseMessage(String messageID, String targetKey) {
		this(messageID, targetKey, SendingBehavior.SEND_MAX_ALLOWED_TIMES);
	}

	/**
	 * Convenience method to create a random message ID
	 * 
	 * @return a random String of 12 characters length
	 */
	protected static String createMessageID() {
		return new BigInteger(56, new SecureRandom()).toString(32);
	}

	/**
	 * Getter
	 * 
	 * @return the ID of this message
	 */
	public String getMessageID() {
		return messageID;
	}

	/**
	 * Getter
	 * 
	 * @return the target key of this message
	 */
	public String getTargetKey() {
		return targetKey;
	}

	/**
	 * This method is called on the receiver node (the one responsible for {@link #targetKey}) of this
	 * message. It is used to check if the target
	 * node is able/willing to handle this message at all.</br>
	 * 
	 * For more information on how the value generated by this method is used
	 * see {@link MessageReplyHandler#reply(net.tomp2p.peers.PeerAddress, Object)} and
	 * {@link MessageManager.FutureListener#extractAcceptanceReply(FutureDHT)} &
	 * {@link MessageManager.FutureListener2#extractAcceptanceReply(FutureDHT)}.
	 * </br></br>
	 * 
	 * <b>Important:</b></br> All concrete subclasses have to implement this
	 * method and adhere to the following points:</br> <li>This method must terminate as quickly as possible.</li>
	 * <li>No blocking in any way is allowed.</li> <li>No sending of messages or other network activities are
	 * permitted.</li>
	 * 
	 * @return the {@link AcceptanceReply} of the target node.
	 */
	public abstract AcceptanceReply accept();

	/**
	 * Setter
	 * 
	 * @param aNetworkManager
	 *            the {@link NetworkManager} to be used by this message
	 */
	public void setNetworkManager(NetworkManager aNetworkManager) {
		networkManager = aNetworkManager;
	}

	/**
	 * Increases the internal sending counter of this message.
	 */
	public void increaseSendingCounter() {
		sendingCounter++;
	}

	/**
	 * Getter
	 * 
	 * @return the current value of this messages sending counter
	 */
	public int getSendingCounter() {
		return sendingCounter;
	}

	/**
	 * Getter
	 * 
	 * @return the {@link SendingBehavior} for this message
	 */
	public SendingBehavior getSendingBehavior() {
		return sendingBehavior;
	}

	/**
	 * This method is called if a failure is detected while sending this
	 * message. The idea is that sending failures are handled by the message
	 * itself, because the message is the only entity which knows how to perform
	 * from the point of a failure on. Some messages don't need do be sent
	 * again, while others need a redirect or wish to inform special (potential
	 * several) customers about the failure.</br> This abstract class implements
	 * the default behavior for {@link SendingBehavior#SEND_MAX_ALLOWED_TIMES}.
	 * Subclasses which need a different or more elaborated failure handling
	 * have to extend or override this method.
	 * 
	 * @param reply
	 *            the reply of the sending attempt
	 * @param aNetworkManager
	 *            a handle to the local {@link NetworkManager} which can be used
	 *            for resending or notification tasks
	 */
	public void handleSendingFailure(AcceptanceReply reply, NetworkManager aNetworkManager) {
		switch (reply) {
			case OK:
				logger.error("Trying to handle a AcceptanceReply.OK as a failure.");
				throw new IllegalArgumentException("AcceptanceReply.OK is not a failure.");
			case FAILURE:
				if (SendingBehavior.SEND_MAX_ALLOWED_TIMES == getSendingBehavior()) {
					if (getSendingCounter() < H2HConstants.MAX_MESSAGE_SENDING) {
						aNetworkManager.send(this);
					} else {
						logger.error(String
								.format("Message does not getting accepted by the targets in %d tries. Details:\n source nodeID = '%s' target key = '%s'",
										getSendingCounter(), aNetworkManager.getNodeId(), getTargetKey()));
					}
				} else {
					logger.warn(String
							.format("Message not accepted by the target after one try. Details:\n target key = '%s' message id = '%s'",
									getTargetKey(), messageID));
				}
				break;
			default:
				logger.error(String.format("Unkown AcceptanceReply argument: %s", reply));
				throw new IllegalArgumentException(
						String.format("Unkown AcceptanceReply argument: %s", reply));
		}
	}
}

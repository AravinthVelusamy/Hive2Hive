package org.hive2hive.core.network.messages;

import java.io.Serializable;
import java.math.BigInteger;
import java.security.SecureRandom;

import net.tomp2p.futures.FutureDHT;
import net.tomp2p.peers.PeerAddress;

import org.hive2hive.core.H2HConstants;
import org.hive2hive.core.log.H2HLogger;
import org.hive2hive.core.log.H2HLoggerFactory;
import org.hive2hive.core.network.NetworkManager;

/**
 * This is the base class of all messages used by <code>Hive2Hive</code>.</br>
 * All messages are sent to their destination in an asynchronous manner.<br>
 * </br>
 * 
 * <b>Design decision:</b></br> All messages in <code>Hive2Hive</code> have to
 * be send asynchronously. The reason is simply to avoid timeouts caused by
 * blocking threads which wait for the messages return/completion. If we wait
 * for a message to return and block the current thread (the synchronous way of
 * doing it) the current node itself is not able to reply on incoming messages.
 * This leads to timeouts for requesters and as a consequence to messages routed
 * to the 'wrong' peer/node because <code>TomP2P</code> thinks the current node
 * has left the network...</br></br>
 * 
 * Messages are sent by the {@link MessageManager}. For more details please have
 * a look at {@link MessageManager#send(BaseMessage)}.
 * 
 * @author Nendor, Seppi
 * 
 */
public abstract class BaseMessage implements Runnable, Serializable {

	private static final H2HLogger logger = H2HLoggerFactory.getLogger(BaseMessage.class);

	private static final long serialVersionUID = 8896590561336373601L;

	protected NetworkManager networkManager;

	private final String messageID;
	private final String targetKey;
	private final PeerAddress senderAddress;
	private final SendingBehavior sendingBehavior;

	private int sendingCounter = 0;

	/**
	 * Constructor for an asynchronous message.
	 * 
	 * @param messageID
	 *            the ID of this message - should be chosen uniquely if possible
	 * @param targetKey
	 *            the key identifying the target of this message
	 * @param senderAddress
	 *            peer address of the sender
	 * @param sendingBehavior
	 *            the sending behavior used for this message
	 */
	public BaseMessage(String messageID, String targetKey, PeerAddress senderAddress,
			SendingBehavior sendingBehavior) {
		this.messageID = messageID;
		this.targetKey = targetKey;
		this.senderAddress = senderAddress;
		this.sendingBehavior = sendingBehavior;
	}

	/**
	 * Constructor for an asynchronous message.</br> This constructor creates an
	 * asynchronous message with the default sending behavior {@link SendingBehavior#SEND_MAX_ALLOWED_TIMES}.
	 * 
	 * @param messageID
	 *            the ID of this message - should be chosen uniquely if possible
	 * @param targetKey
	 *            the key identifying the target of this message
	 * @param senderAddress
	 *            peer address of the sender
	 */
	public BaseMessage(String messageID, String targetKey, PeerAddress senderAddress) {
		this(messageID, targetKey, senderAddress, SendingBehavior.SEND_MAX_ALLOWED_TIMES);
	}

	/**
	 * Getter
	 * 
	 * @return the ID of this message
	 */
	public String getMessageID() {
		return messageID;
	}

	/**
	 * Getter
	 * 
	 * @return the target key of this message
	 */
	public String getTargetKey() {
		return targetKey;
	}

	/**
	 * Getter
	 * 
	 * @return peer address of the sender
	 */
	public PeerAddress getSenderAddress() {
		return senderAddress;
	}

	/**
	 * Getter
	 * 
	 * @return the current value of this messages sending counter
	 */
	public int getSendingCounter() {
		return sendingCounter;
	}

	/**
	 * Getter
	 * 
	 * @return the {@link SendingBehavior} for this message
	 */
	public SendingBehavior getSendingBehavior() {
		return sendingBehavior;
	}

	/**
	 * Setter
	 * 
	 * @param aNetworkManager
	 *            the {@link NetworkManager} to be used by this message
	 */
	public void setNetworkManager(NetworkManager aNetworkManager) {
		networkManager = aNetworkManager;
	}

	/**
	 * Increases the internal sending counter of this message.
	 */
	public void increaseSendingCounter() {
		sendingCounter++;
	}

	/**
	 * This method is called on the receiver node (the one responsible for {@link #targetKey}) of this
	 * message. It is used to check if the target node is able/willing to handle this message at all.</br>
	 * 
	 * For more information on how the value generated by this method is used
	 * see {@link MessageReplyHandler#reply(net.tomp2p.peers.PeerAddress, Object)} and
	 * {@link MessageManager.FutureListener#extractAcceptanceReply(FutureDHT)} &
	 * {@link MessageManager.FutureListener2#extractAcceptanceReply(FutureDHT)}.
	 * </br></br>
	 * 
	 * <b>Important:</b></br> All concrete subclasses have to implement this
	 * method and adhere to the following points:</br> <li>This method must terminate as quickly as possible.</li>
	 * <li>No blocking in any way is allowed.</li> <li>No sending of messages or other network activities are
	 * permitted.</li>
	 * 
	 * @return the {@link AcceptanceReply} of the target node.
	 */
	public abstract AcceptanceReply accept();

	/**
	 * Convenience method to create a random message ID
	 * 
	 * @return a random String of 12 characters length
	 */
	protected static String createMessageID() {
		return new BigInteger(56, new SecureRandom()).toString(32);
	}

}
